"use strict";
exports.__esModule = true;
var suf_regex_1 = require("suf-regex");
/**
 * returns the relative distance that the class or id should be at.
 */
function getCLassOrIdIndentationOffset(distance, tabSize, current, ignoreCurrent) {
    if (distance === 0) {
        return 0;
    }
    if (tabSize * Math.round(distance / tabSize - 0.1) > current && !ignoreCurrent) {
        return current - distance;
    }
    return tabSize * Math.round(distance / tabSize - 0.1) - distance;
}
exports.getCLassOrIdIndentationOffset = getCLassOrIdIndentationOffset;
/**
 * adds or removes whitespace based on the given offset, a positive value adds whitespace a negative value removes it.
 */
function replaceWithOffset(text, offset, options) {
    if (offset < 0) {
        text = text.replace(/\t/g, ' '.repeat(options.tabSize)).replace(new RegExp("^ {" + Math.abs(offset) + "}"), '');
        if (!options.insertSpaces) {
            text = replaceSpacesOrTabs(text, false, options.tabSize);
        }
    }
    else {
        text = text.replace(/^/, options.insertSpaces ? ' '.repeat(offset) : '\t'.repeat(offset / options.tabSize));
    }
    return text;
}
exports.replaceWithOffset = replaceWithOffset;
/**
 * returns the difference between the current indentation and the indentation of the given text.
 */
function getIndentationOffset(text, indentation, tabSize) {
    var distance = suf_regex_1.getDistance(text, tabSize);
    return { offset: indentation - distance, distance: distance };
}
exports.getIndentationOffset = getIndentationOffset;
/**
 *
 */
function isKeyframePoint(text, isAtKeyframe) {
    if (isAtKeyframe === false) {
        return false;
    }
    return /^[\t ]*\d+%/.test(text) || /^[\t ]*from|^[\t ]*to/.test(text);
}
exports.isKeyframePoint = isKeyframePoint;
/**
 * if the Property Value Space is none or more that one, this function returns false, else true;
 */
function hasPropertyValueSpace(text) {
    var split = text.split(':');
    return split[1] === undefined
        ? true
        : split[1][0] === undefined
            ? true
            : split[1].startsWith(' ')
                ? split[1][1] === undefined
                    ? true
                    : !split[1][1].startsWith(' ')
                : false;
}
exports.hasPropertyValueSpace = hasPropertyValueSpace;
/**
 * converts scss/css to sass.
 */
function convertScssOrCss(text, options, lastSelector) {
    var isMultiple = suf_regex_1.isMoreThanOneClassOrId(text);
    StoreConvertInfo('CSS CONVERT');
    StoreConvertInfo(" TEXT: " + text);
    if (lastSelector && new RegExp('^.*' + suf_regex_1.escapeRegExp(lastSelector)).test(text)) {
        StoreConvertInfo(' +  LAST SELECTOR');
        var newText = text.replace(lastSelector, '');
        if (suf_regex_1.isPseudoWithParenthesis(text)) {
            newText = newText.split('(')[0].trim() + '(&' + ')';
        }
        else if (text.trim().startsWith(lastSelector)) {
            newText = text.replace(lastSelector, '&');
        }
        else {
            newText = newText.replace(/ /g, '') + ' &';
        }
        return {
            lastSelector: lastSelector,
            increaseTabSize: true,
            text: replaceWithOffset(removeInvalidChars(newText).trimRight(), options.tabSize, options)
        };
    }
    else if (suf_regex_1.isCssOneLiner(text)) {
        StoreConvertInfo(' +  ONE LINER');
        var split = text.split('{');
        return {
            increaseTabSize: false,
            lastSelector: split[0].trim(),
            text: removeInvalidChars(split[0].trim().concat('\n', replaceWithOffset(split[1].trim(), options.tabSize, options))).trimRight()
        };
    }
    else if (suf_regex_1.isCssPseudo(text) && !isMultiple) {
        StoreConvertInfo(' +  PSEUDO');
        return {
            increaseTabSize: false,
            lastSelector: lastSelector,
            text: removeInvalidChars(text).trimRight()
        };
    }
    else if (suf_regex_1.isClassOrId(text)) {
        StoreConvertInfo(' +  CLASS OR ID');
        lastSelector = removeInvalidChars(text).trimRight();
    }
    StoreConvertInfo(' END/DEFAULT');
    return { text: removeInvalidChars(text).trimRight(), increaseTabSize: false, lastSelector: lastSelector };
}
exports.convertScssOrCss = convertScssOrCss;
function removeInvalidChars(text) {
    var newText = '';
    var isInQuotes = false;
    var isInComment = false;
    var isInVarSelector = false;
    for (var i = 0; i < text.length; i++) {
        var char = text[i];
        if (!isInQuotes && char === '/' && text[i + 1] === '/') {
            isInComment = true;
        }
        else if (/['"]/.test(char)) {
            isInQuotes = !isInQuotes;
        }
        else if (/#/.test(char) && /{/.test(text[i + 1])) {
            isInVarSelector = true;
        }
        else if (isInVarSelector && /}/.test(text[i - 1])) {
            isInVarSelector = false;
        }
        if (!/[;\{\}]/.test(char) || isInQuotes || isInComment || isInVarSelector) {
            newText += char;
        }
    }
    return newText;
}
function replaceSpacesOrTabs(text, useSpaces, tabSize) {
    if (useSpaces) {
        return text.replace(/\t/g, ' '.repeat(tabSize));
    }
    else {
        return text.replace(new RegExp(' '.repeat(tabSize), 'g'), '\t');
    }
}
exports.replaceSpacesOrTabs = replaceSpacesOrTabs;
function LogFormatInfo(enableDebug, lineNumber, info) {
    if (enableDebug) {
        console.log(' ', info.title, 'Row:', lineNumber + 1, info.offset !== undefined ? "Offset: " + info.offset : '', '\n    ', 'PROPERTY SPACE : ', info.setSpace !== undefined ? info.setSpace : 'not provided', '\n    ', 'CONVERT        : ', info.convert !== undefined ? info.convert : 'not provided', '\n    ', 'NEXT LINE      : ', info.nextLine !== undefined ? info.nextLine : 'not provided', '\n    ', 'REPLACE        : ', info.replaceSpaceOrTabs !== undefined ? info.replaceSpaceOrTabs : 'not provided', StoreCssConvertLog.log.length > 0 ? '\n' : '', StoreCssConvertLog.log.join('\n'));
        StoreCssConvertLog.log = [];
    }
    else {
        StoreCssConvertLog.log = [];
    }
}
exports.LogFormatInfo = LogFormatInfo;
function StoreConvertInfo(title) {
    StoreCssConvertLog.log.push("      " + title);
}
var StoreCssConvertLog = /** @class */ (function () {
    function StoreCssConvertLog() {
    }
    StoreCssConvertLog.log = [];
    return StoreCssConvertLog;
}());
